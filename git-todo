#!/bin/sh
set -e
  GIT_OPTS=""
  OUTPUT_FILTER="cat" # no-op
  RED=$(tput setaf 1)
  GREEN=$(tput setaf 2)
  TODO_FLAG='@todo';
  DONE_FLAG='@done'
  reset=$(tput sgr0)
  ifs=$IFS
  notes=""
  from_commit=""

get_notes()
{
  notes_rev=$( \
    for rev in $( git rev-list -25 HEAD ); do
      git notes list $rev 2>/dev/null && break;
    done \
  );
  if [ $notes_rev ]; then
    IFS=""
    notes=$( git cat-file -p $notes_rev )
  fi;

  echo $notes

  if [ -z "$notes" ]; then
    echo "No notes found"
    exit 1
  fi;
}

# List all todos
show()
{
  get_notes;

  echo "$GREEN$DONE_FLAG$reset"
  echo $notes \
  | grep $DONE_FLAG \
  | sed -e "s/$DONE_FLAG//" \
  | while read -a task; do
    echo "$GREEN- [x]$reset${task}"
  done

  echo "$RED$TODO_FLAG$reset"
  echo $notes \
  | grep $TODO_FLAG \
  | sed -e "s/$TODO_FLAG//" \
  | while read -a task; do
    echo "$RED- [ ]$reset${task}"
  done
}

# Create a new Todo
add()
{
  git notes append -m "$TODO_FLAG $@"

  show
}

# Get rid of a todo
remove()
{
  echo $@
}

# Commit a todo as finished
finish() {
  get_notes;

  # echo $notes \
  # | grep $DONE_FLAG \
  # | sed -e "s/$DONE_FLAG/- [x]/"

  echo $notes \
  | grep $TODO_FLAG \
  | sed -e "s/$TODO_FLAG//" \
  | cat -n

  read -p "Choose a \`$TODO_FLAG' to commit: " selection

  message=$( echo $notes \
    | grep $TODO_FLAG \
    | sed -e "s/$TODO_FLAG//" \
    | cat -n \
    | grep "^\s*$selection" \
    | sed "s/$selection//" \
    | xargs # this is definitely a hack... i have no idea why this works
  )

  if [ -z $message ]; then
    echo "No matching todo"
    exit 1
  fi

  if [ $( git diff --cached --quiet ) $? -eq 0 ]; then
    echo "Nothing staged for commit"
    exit 1
  fi

  git commit -m "$message"
  git notes add "$(sed "s/$TODO_FLAG $message/$DONE_FLAG $message/" <<< $notes)"

  show
}

help()
{
  echo "usage: git todo show";
  echo "   or: git todo add";
  echo "   or: git todo remove";
  echo "   or: git todo finish";
}

# list
IFS=$ifs
case $1 in
  'show')
    shift;
    show "$@" ;;
  'add')
    shift;
    add "$@" ;;
  'remove')
    shift;
    remove "$0" ;;
  'finish')
    shift;
    finish "$@" ;;
  'help')
    help;;
  *)
    echo "error: unknown subcommand: $1"
    help;;
esac
